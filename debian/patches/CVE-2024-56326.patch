[Ubuntu note: Changes on original src/jinja2/sandbox.py are applied to
jinja2/sandbox.py instead. `wrap_str_format` in sandbox.py also adjusted
to be compatible with python2 and python3. Specifically, f_self is returns 
None if value is not an instance of str and not an instance of Markup. 
 -- Evan Caville <evan.caville@canonical.com>]
From 91a972f5808973cd441f4dc06873b2f8378f30c7 Mon Sep 17 00:00:00 2001
From: Lydxn <hlyndon20@gmail.com>
Date: Mon, 23 Sep 2024 15:09:10 -0700
Subject: [PATCH] sandbox indirect calls to str.format

---
 CHANGES.rst            |  3 ++
 src/jinja2/sandbox.py  | 81 ++++++++++++++++++++++--------------------
 tests/test_security.py | 17 +++++++++
 3 files changed, 63 insertions(+), 38 deletions(-)

--- a/tests/test_security.py
+++ b/tests/test_security.py
@@ -206,3 +206,22 @@
         env = SandboxedEnvironment()
         t = env.from_string('{{ ("a{x.foo}b{y}"|safe).format_map({"x":{"foo": 42}, "y":"<foo>"}) }}')
         assert t.render() == 'a42b&lt;foo&gt;'
+
+
+    def test_indirect_call(self):
+        def run(value, arg):
+            return value.run(arg)
+
+        env = SandboxedEnvironment()
+        env.filters["run"] = run
+        t = env.from_string(
+            """{% set
+                ns = namespace(run="{0.__call__.__builtins__[__import__]}".format)
+            %}
+            {{ ns | run(not_here) }}
+            """
+        )
+
+        with pytest.raises(SecurityError):
+            t.render()
+
--- a/jinja2/sandbox.py
+++ b/jinja2/sandbox.py
@@ -20,6 +20,7 @@
 except:
     from collections.abc import Mapping
 
+from functools import update_wrapper
 from jinja2.environment import Environment
 from jinja2.exceptions import SecurityError
 from jinja2._compat import string_types, PY2
@@ -146,16 +147,6 @@
         return len(self._kwargs)
 
 
-def inspect_format_method(callable):
-    if not isinstance(callable, (types.MethodType,
-                                 types.BuiltinMethodType)) or \
-       callable.__name__ not in ('format', 'format_map'):
-        return None
-    obj = callable.__self__
-    if isinstance(obj, string_types):
-        return obj
-
-
 def safe_range(*args):
     """A range that can't generate ranges with a length of more than
     MAX_RANGE items.
@@ -384,6 +375,9 @@
                     except AttributeError:
                         pass
                     else:
+                        fmt = self.wrap_str_format(value)
+                        if fmt is not None:
+                            return fmt
                         if self.is_safe_attribute(obj, argument, value):
                             return value
                         return self.unsafe_undefined(obj, argument)
@@ -401,6 +395,9 @@
             except (TypeError, LookupError):
                 pass
         else:
+            fmt = self.wrap_str_format(value)
+            if fmt is not None:
+                return fmt
             if self.is_safe_attribute(obj, attribute, value):
                 return value
             return self.unsafe_undefined(obj, attribute)
@@ -414,34 +411,52 @@
             obj.__class__.__name__
         ), name=attribute, obj=obj, exc=SecurityError)
 
-    def format_string(self, s, args, kwargs, format_func=None):
-        """If a format call is detected, then this is routed through this
-        method so that our safety sandbox can be used for it.
+    def wrap_str_format(self, value):
+        """If the given value is a ``str.format`` or ``str.format_map`` method,
+        return a new function than handles sandboxing. This is done at access
+        rather than in :meth:`call`, so that calls made without ``call`` are
+        also sandboxed.
         """
-        if isinstance(s, Markup):
-            formatter = SandboxedEscapeFormatter(self, s.escape)
+        if not isinstance(
+            value, (types.MethodType, types.BuiltinMethodType)
+        ) or value.__name__ not in ("format", "format_map"):
+            return None
+
+        f_self = value.__self__
+
+        if not isinstance(f_self, str) and not isinstance(f_self, Markup):
+            return None
+
+        str_type = type(f_self)
+        is_format_map = value.__name__ == "format_map"
+        if isinstance(f_self, Markup):
+            formatter = SandboxedEscapeFormatter(self, f_self.escape)
         else:
             formatter = SandboxedFormatter(self)
 
-        if format_func is not None and format_func.__name__ == 'format_map':
-            if len(args) != 1 or kwargs:
-                raise TypeError(
-                    'format_map() takes exactly one argument %d given'
-                    % (len(args) + (kwargs is not None))
-                )
-
-            kwargs = args[0]
-            args = None
-
-        kwargs = _MagicFormatMapping(args, kwargs)
-        rv = formatter.vformat(s, args, kwargs)
-        return type(s)(rv)
+        vformat = formatter.vformat
+
+        def wrapper(*args, **kwargs):
+            if is_format_map:
+                if kwargs:
+                    raise TypeError("format_map() takes no keyword arguments")
+
+                if len(args) != 1:
+                    raise TypeError(
+                        'format_map() takes exactly one argument (%d given)'
+                        % (len(args))
+                    )
+
+                kwargs = args[0]
+                args = None
+
+            kwargs = _MagicFormatMapping(args, kwargs)
+            return str_type(vformat(f_self, args, kwargs))
+
+        return update_wrapper(wrapper, value)
 
     def call(__self, __context, __obj, *args, **kwargs):
         """Call an object from sandboxed code."""
-        fmt = inspect_format_method(__obj)
-        if fmt is not None:
-            return __self.format_string(fmt, args, kwargs, __obj)
 
         # the double prefixes are to avoid double keyword argument
         # errors when proxying the call.
